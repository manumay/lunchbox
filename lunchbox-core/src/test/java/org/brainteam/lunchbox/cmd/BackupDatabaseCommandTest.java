package org.brainteam.lunchbox.cmd;import static org.mockito.Matchers.any;import static org.mockito.Mockito.verify;import static org.mockito.Mockito.when;import static org.testng.Assert.assertEquals;import static org.testng.Assert.assertNotNull;import java.sql.CallableStatement;import java.sql.Connection;import java.sql.SQLException;import javax.sql.DataSource;import org.apache.commons.io.FileUtils;import org.brainteam.lunchbox.cmd.BackupDatabaseAction;import org.brainteam.lunchbox.cmd.CommandException;import org.brainteam.lunchbox.core.Directories;import org.brainteam.lunchbox.i18n.Translator;import org.mockito.InjectMocks;import org.mockito.Mock;import org.mockito.MockitoAnnotations;import org.testng.annotations.BeforeClass;import org.testng.annotations.Test;@Test(groups="unit")public class BackupDatabaseCommandTest {		private static final String TRANSLATED = "translated";		@Mock	private Translator translator;		@Mock	private DataSource dataSource;		@Mock	private Connection connection;		@Mock	private CallableStatement cs;		@Mock	private Directories directories;	@InjectMocks	private BackupDatabaseAction command = new BackupDatabaseAction();		@BeforeClass	public void setup() throws SQLException {		MockitoAnnotations.initMocks(this);		when(translator.t(any(String.class))).thenReturn(TRANSLATED);		when(dataSource.getConnection()).thenReturn(connection);		when(connection.prepareCall(any(String.class))).thenReturn(cs);		when(directories.getBackupDir()).thenReturn(FileUtils.getTempDirectory());	}		@Test	public void testGetName() {		String name = command.getName();		assertNotNull(name);		assertEquals(name, TRANSLATED);		verify(translator).t(BackupDatabaseAction.NAME);	}		@Test	public void testExecute() throws CommandException, SQLException {		command.execute();		verify(dataSource).getConnection();		verify(connection).prepareCall(any(String.class));		verify(cs).execute();	}	}