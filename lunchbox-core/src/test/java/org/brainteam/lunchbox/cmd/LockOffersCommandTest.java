package org.brainteam.lunchbox.cmd;import static org.mockito.Matchers.any;import static org.mockito.Mockito.verify;import static org.mockito.Mockito.when;import static org.testng.Assert.assertEquals;import static org.testng.Assert.assertNotNull;import java.sql.SQLException;import org.brainteam.lunchbox.cmd.CommandException;import org.brainteam.lunchbox.cmd.LockOffersCommand;import org.brainteam.lunchbox.i18n.Translator;import org.brainteam.lunchbox.services.OfferService;import org.mockito.InjectMocks;import org.mockito.Mock;import org.mockito.MockitoAnnotations;import org.testng.annotations.BeforeClass;import org.testng.annotations.Test;@Test(groups="unit")public class LockOffersCommandTest {	private static final String TRANSLATED = "translated";		@Mock	private Translator translator;		@Mock	private OfferService offerService;	@InjectMocks	private LockOffersCommand command = new LockOffersCommand();		@BeforeClass	public void setup() throws SQLException {		MockitoAnnotations.initMocks(this);		when(translator.t(any(String.class))).thenReturn(TRANSLATED);	}		@Test	public void testGetName() {		String name = command.getName();		assertNotNull(name);		assertEquals(name, TRANSLATED);		verify(translator).t(LockOffersCommand.NAME);	}		@Test	public void testExecute() throws CommandException {		command.execute();		verify(offerService).lockNext();	}	}