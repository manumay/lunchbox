package org.brainteam.lunchbox.cmd;import static org.mockito.Matchers.any;import static org.mockito.Matchers.eq;import static org.mockito.Mockito.verify;import static org.mockito.Mockito.when;import static org.testng.Assert.assertEquals;import static org.testng.Assert.assertNotNull;import java.sql.SQLException;import java.util.List;import org.brainteam.lunchbox.cmd.CommandException;import org.brainteam.lunchbox.cmd.MailBillingCommand;import org.brainteam.lunchbox.i18n.Translator;import org.brainteam.lunchbox.json.JsonOrdersBilling;import org.brainteam.lunchbox.services.MailService;import org.brainteam.lunchbox.services.ReportService;import org.mockito.InjectMocks;import org.mockito.Mock;import org.mockito.MockitoAnnotations;import org.testng.annotations.BeforeClass;import org.testng.annotations.Test;@Test(groups="unit")public class MailBillingCommandTest {		private static final String TRANSLATED = "translated";		@Mock	private List<JsonOrdersBilling> json;		@Mock	private Translator translator;		@Mock	private ReportService reportService;		@Mock	private MailService mailService;		@InjectMocks	private MailBillingCommand command = new MailBillingCommand();		@BeforeClass	public void setup() throws SQLException {		MockitoAnnotations.initMocks(this);		when(translator.t(any(String.class))).thenReturn(TRANSLATED);		when(reportService.getBillingReportJson(any(Integer.class), any(Integer.class), any(Integer.class))).thenReturn(json);	}		@Test	public void testGetName() {		String name = command.getName();		assertNotNull(name);		assertEquals(name, TRANSLATED);		verify(translator).t(MailBillingCommand.NAME);	}		@Test	public void testExecute() throws CommandException {		command.execute();		verify(reportService).getBillingReportJson(any(Integer.class), any(Integer.class), eq(12));		verify(mailService).mailBilling(json);	}}