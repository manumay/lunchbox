package org.brainteam.lunchbox.jmx;import static org.mockito.Mockito.when;import static org.testng.Assert.assertEquals;import static org.testng.Assert.assertTrue;import static org.testng.Assert.fail;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.util.Properties;import org.apache.commons.io.FileUtils;import org.brainteam.lunchbox.core.Directories;import org.mockito.Mock;import org.mockito.MockitoAnnotations;import org.testng.annotations.BeforeMethod;public abstract class BaseConfigurationTest {		private static File BASEDIR = FileUtils.getTempDirectory();		@Mock	private Directories directories;		@BeforeMethod(groups={ "unit-jmx" })	public void setup() {		MockitoAnnotations.initMocks(this);		when(directories.getConfigDir()).thenReturn(BASEDIR);		File f = getFile();		if (f.exists()) {			f.delete();		}	}		public void testGetAndSet(TestCase getAndSet) {		getAndSet.test();	}		protected abstract String getFilename();		protected final File getFile() {		return new File(BASEDIR, getFilename());	}		protected abstract class TestCase {				protected abstract String getPropertyName();				protected abstract Object getDefaultValue();				protected abstract Object getUpdateValue();				protected abstract Object getCurrentValue(); 				protected abstract void setValue( Object value);				final void test() {			checkValue(getDefaultValue());			assertPropertyWritten(getPropertyName(), getDefaultValue());			setValue(getUpdateValue());			checkValue(getUpdateValue());			assertPropertyWritten(getPropertyName(), getUpdateValue());		}				void checkValue(Object expectedValue) {			assertEquals(expectedValue, getCurrentValue());		}				final void assertConfigFileExists() {			assertTrue(getFile().exists());				}				final void assertPropertyWritten(String key, Object expected) {			assertConfigFileExists();			try {				Properties p = new Properties();				p.load(new FileInputStream(getFile()));				assertEquals(p.getProperty(key), String.valueOf(expected));			} catch (IOException e) {				fail(e.getMessage());			}		}			}	}