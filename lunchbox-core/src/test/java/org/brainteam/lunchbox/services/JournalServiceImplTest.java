package org.brainteam.lunchbox.services;import static org.mockito.Matchers.any;import static org.mockito.Matchers.eq;import static org.mockito.Mockito.verify;import static org.mockito.Mockito.when;import static org.testng.Assert.assertEquals;import static org.testng.Assert.assertNotNull;import static org.testng.Assert.assertNull;import java.util.ArrayList;import java.util.Date;import java.util.List;import org.brainteam.lunchbox.core.Clock;import org.brainteam.lunchbox.dao.JournalRepository;import org.brainteam.lunchbox.domain.Journal;import org.brainteam.lunchbox.domain.User;import org.brainteam.lunchbox.i18n.Translator;import org.mockito.ArgumentCaptor;import org.mockito.InjectMocks;import org.mockito.Mock;import org.mockito.MockitoAnnotations;import org.mockito.Spy;import org.testng.annotations.BeforeClass;import org.testng.annotations.Test;@Test(groups={"unit"})public class JournalServiceImplTest {		private static final String TEXTKEY = "textkey";	private static final String TRANSLATED = "translated";		@Mock	private Translator translator;		@Mock	private UserService userService;		@Mock	private JournalRepository journalRepository;	@Mock	private User user;		@Mock	private Clock clock;		@Mock	private Journal journal;		@Spy	private List<Journal> journals = new ArrayList<>();	@InjectMocks	private JournalService journalService = new JournalServiceImpl();	//	private Date emptyStartDate = DateUtils.getDay(1, 1, 2000);//	private Date notEmptyStartDate = DateUtils.getDay(1, 1, 2001);		@BeforeClass    public void init() {		MockitoAnnotations.initMocks(this);		journals.add(journal);		journals.add(journal);		when(translator.t(eq(TEXTKEY), any(Object[].class))).thenReturn(TRANSLATED);		when(userService.currentModifier()).thenReturn(user);		when(clock.now()).thenReturn(new Date());		when(journal.getModifier()).thenReturn(user);		when(journal.getTextKey()).thenReturn(TEXTKEY);		when(journal.getModificationDate()).thenReturn(new Date());//		when(journalRepository.findByFromAndTillOrderByModificationDate(eq(emptyStartDate), any(Date.class))).thenReturn(new ArrayList<Journal>());//		when(journalRepository.findByFromAndTillOrderByModificationDate(eq(notEmptyStartDate), any(Date.class))).thenReturn(journals);    }		@Test	public void testAdd() {		journalService.add("", new String[] {});				ArgumentCaptor<Journal> journalCaptor = ArgumentCaptor.forClass(Journal.class);		verify(journalRepository).save(journalCaptor.capture());				Journal journal = journalCaptor.getValue();		assertNotNull(journal);		assertNull(journal.getId());		assertNotNull(journal.getModificationDate());		assertEquals(user, journal.getModifier());		assertEquals("", journal.getParams());		assertEquals("", journal.getTextKey());		assertNull(journal.getVersion());	}	//	@Test//	public void testJsonEmpty() {//		JsonJournal json = journalService.getJson(emptyStartDate);//		assertNotNull(json);//		assertEquals(emptyStartDate, json.getDate());//		assertNotNull(json.getItems());//		assertTrue(json.getItems().isEmpty());//	}	//	@Test//	public void testJson() {//		JsonJournal json = journalService.getJson(notEmptyStartDate);//		assertNotNull(json);//		assertEquals(json.getDate(), notEmptyStartDate);//		assertNotNull(json.getItems());//		assertEquals(json.getItems().size(), journals.size());//		//		if (!journals.isEmpty()) {//			for (JsonJournalItem item : json.getItems()) {//				assertNotNull(item);//				assertNotNull(item.getTimestamp());//				assertNotNull(item.getText());//				assertNotNull(item.getUser());//			}//		}//	}}